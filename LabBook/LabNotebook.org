#+AUTHOR: Austin Vihncent Skeeters
#+EMAIL:  avs11d@my.fsu.edu
#+STARTUP: showall
#+STARTUP: showstars
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LATEX_CLASS: book
#+LaTeX_CLASS_OPTIONS: [listings, listings-color, listings-bw]
#+LaTeX_CLASS_OPTIONS: [11 pt , letterpaper , twoside , openright]
#+LATEX_HEADER: \usepackage[AUTO]{inputenc}
#+LaTeX_HEADER: \lstset{tabsize=4,language=C++,captionpos=b,frame=lines,numbers=left,numberstyle=\tiny,numbersep=5pt,breaklines = true,showstringspaces=false,basicstyle=\footnotesize,keywordstyle=\color{blue},commentstyle=\color{red},stringstyle=\color{green}}
#+LaTeX_HEADER: \lstset{tabsize=4,language=Python,captionpos=b,frame=lines,numbers=left,numberstyle=\tiny,numbersep=5pt,breaklines = true,showstringspaces=false,basicstyle=\footnotesize,keywordstyle=\color{blue},commentstyle=\color{red},stringstyle=\color{green}}
#+LaTeX_HEADER: \lstset{tabsize=4,language=sh,captionpos=b,frame=lines,numbers=left,numberstyle=\tiny,numbersep=5pt,breaklines = true,showstringspaces=false,basicstyle=\footnotesize,keywordstyle=\color{blue},commentstyle=\color{red},stringstyle=\color{green}}
#+LaTeX_HEADER: \lstset{tabsize=4,language=bash,captionpos=b,frame=lines,numbers=left,numberstyle=\tiny,numbersep=5pt,breaklines = true,showstringspaces=false,basicstyle=\footnotesize,keywordstyle=\color{blue},commentstyle=\color{red},stringstyle=\color{green}}

* Venkatesh Thesis Notes                                           :noexport:
** Standard Model
   [[./Figures/StandardModel.png]]
   + Hadrons
     + Mesons :: Quark and Anti-Quark $q\bar{q}$
     + Baryons :: All Quarks or All Anti-Quarks $qqq/\bar{q}\bar{q}\bar{q}$
                  
** Standard Model Shortcomings
   + Matter-Antimatter Asymmetry
   + Accelerating Expansion of Universe :: Dark Energy?
   + Constant Angular Velocity of Spiral Galaxies :: Dark Matter?
   + Hierarchy Problem :: Gravitational force so much weaker than others
   + Grand Unification :: Possible inability to distinguish between
        fundamental forces at high enough energy scales

** Beyond SM Theories
   Conserved or almost conserved quantum numbers can result in stable
   or long-lived particles called *Heavy Stable Charged Particles
   (HSCP)*.
   
*** Heavy Stable Charged Particles
    + Fractional ($|Q|<e$)
    + Unit ($|Q|=e$)
    + Multiple ($|Q|>e$)
       
*** Q Balls
    Could have been formed during the early universe through phase
    transitions and fusion, or by aggregation of net charge in a
    region through statistical fluctuations.

** Search for Multiply Charged HSCPs in High Energy Colliders
   + *Massive* = $m>100 GeV$
   + Unstable, but long enough lifetime to be detected
   + Need $\approx 5ns$ to traverse detector
   + Interact primarily electromagnetically
   + Enhanced ionization energy loss due to larger $Q$ for
     nonrelativistic MCHSCPs
   + *Bethe-Bloche Formula* :: Describes average electromagnetic
        energy loss per unit pathlength of a charged particle
        traversing a medium.
        $-\left<\frac{dE}{dx}\right>=4\pi
        N_{A}r_{e}^2m_{e}c^2z^2\frac{Z}{A}\frac{1}{\beta^2}\left[\frac{1}{2}\ln\frac{2m_ec^2\beta^2\gamma^2T_{max}}{I^2}-\beta^2-\frac{\delta(\beta\gamma)}{2}\right]\times
        Q^2$
     + $N_A$ :: Avogadros Number
     + $m_e$ :: Electron Mass
     + $r_e$ :: Classical Electron Radius
     + $z$ :: Electrical charge of the particle in units of $e$
     + $\beta$ :: $\frac{\nu}{c}$
     + $\gamma$/Lorentz Factor :: $\frac{1}{\sqrt{1-\beta^2}}$
     + $Z$ :: Atomic Number of the Absorber
     + $A$ :: Mass Number of the Absorber
     + $T_{max}$ :: Maximum kinetic energy that can be imparted to a
                    free electron in a single collision
     + $I$ :: Mean excitation potential
     + $\delta(\beta\gamma)$ :: Density effect correction to
          ionization energy loss
     + $Q$ :: Electric charge of the particle
     + Graphical Representation :: [[./Figures/Bethe-Bloch.png]]
     + Qualitative Trends 
       + Minimum energy loss when particle speed is *relativistic*
         ($\beta\gamma\approx 2$)
       + After the above, roughly constant energy loss until radiative
         effects become prominent.
       + $0.1<\beta\gamma<2$ Energy loss increases with a
         $\approx\frac{1}{\beta^2}$ dependence.
       + At much slower speeds ($\beta\gamma <\approx 0.1$) other
         effects must be considered.
       + Overall $Q^2$ dependence for stopping power
     + MHSCP/HSCP Signatures
       + Large energy loss from low velocity and higher charge
       + Often non-relativistic = Higher ionization energy loss
         compared to Standard Model Particles.
       + Even MHSCP at relativistic will have energy loss $Q^2$ times
         higher than SM
     + Issued with detection
       + Slow moving particles can continue to travel through the
         detector for longer time periods than regular SM. So, trigger
         requirements might be missed, and the event rejected.
       + Slow moving particles can trigger during subsequent events
         and thus be incorrectly reconstructed if at all.
       + Must have lower $\beta$ limit where we can expect proper reconstruction.
       
      
               
** The LHC and the CMS
   Experiments in particle physics involve the collisions of two or
   more particles at extremely high energies. The particles are
   brought up to these high energies by accelerators, then forced to
   collide at interaction points surrounded by detectors capable of
   recording and analyzing the event. The obtained information is used
   to infer the particle constituents of a collision/event.
*** The Large Hadron Collider
    + Proton-Proton collider
    + $\approx 10^9$ proton-proton interactions per second
    + $\approx 27$ km in circumference
    + Steps
      1. Electric field applied to H gas separates protons and electrons.
      2. Protons sent to Linac 2, accelerated to 50 MeV.
      3. Proton Synchotron Booster (PSB) to 1.4 GeV.
      4. Proton Synchotron (PS) to 25 GeV.
      5. Super Proton Synchotron (SPS) to 450 GeV.
      6. Grouped into bunches during all accelerations.
         + Numinal bunch number is 2802
         + Nominal proton number in each bunch is $\approx10^{11}$
         + Nominal bunch spacing between successives is 25 ns.
      7. Protons channeled into the two beam pipes of the LHC,
         circulated in opposite directions.
      8. LHC accelerates them to the desired energy.
*** The Compact Muon Solenoid
**** Coordinate System
     + Origin located at the nominal collision point.
     + x-axis points radially inward towards the LHC center.
     + y-axis points vertically upwards.
     + z-axis points along the beam direction per the right-hand rule.
     + Polar angle $\theta$ measured from z-axis. Between y-axis and z-axis.
     + Azimuthal angle $\phi$ measured from the x-axis. In the x-y
       (transverse) plane.
     + Pseudorapidity $\eta = -\ln\tan\left(\frac{\theta}{2}\right)$
       is a Lorentz invariant angular measure. Higher $\eta$, lower
       $\theta$.
     + Transverse Momentum, $p_t$, is the momentum component in the
       transverse plane.
     + Transverse Energy, $E_t = E\sin(\theta)$, is the energy
       component in the transverse plane.
     + The vector momentum imbalance in the transverse plane is known
       as the Missing Transverse Momentum, $\vec{E}_T^{miss}$.
     + The magnitude of the Missing Transverse Momentum is known as
       the Missing Transverse Energy, $E_T^{miss}$.
       
**** Detector Layout
     SEE LAYOUT SECTION FROM VENKATESH THESIS

**** Inner Tracking System


* HSCP Analysis                                                      :export:
** File Generation
*** Useful Twikis
  - https://twiki.cern.ch/twiki/bin/viewauth/CMS/Hscp2014Analysis#Instructions_to_produce_HSCP_sam
  - https://twiki.cern.ch/twiki/bin/view/Main/BatchJobs
  - https://twiki.cern.ch/twiki/bin/view/CMSPublic/SWGuideCmsDriver
*** AOD Files
**** Configuration File Creation

***** Available MC Particle Data
      The directory that contains the list of PYTHIA information for the
      various available particles is:
      #+BEGIN_SRC sh
/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/Configuration/GenProduction/python/ThirteenTeV/
      #+END_SRC
      
      The list of available files is:
    #+tblname: AvailablePythiaInfoTable
| Filename                                           |
|----------------------------------------------------|
| HSCPmchamp12_M_300_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp12_M_900_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp15_M_300_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp15_M_900_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp18_M_300_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp18_M_900_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp1_M_300_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp1_M_900_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp24_M_300_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp24_M_900_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp2_M_300_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp2_M_900_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp30_M_300_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp30_M_900_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp36_M_300_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp36_M_900_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp3_M_1000_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp3_M_100_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp3_M_1400_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp3_M_1800_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp3_M_200_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp3_M_2200_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp3_M_2600_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp3_M_300_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp3_M_400_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp3_M_600_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp3_M_800_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp3_M_900_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp48_M_300_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp48_M_900_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp60_M_300_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp60_M_900_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp6_M_1000_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp6_M_100_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp6_M_1400_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp6_M_1800_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp6_M_200_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp6_M_2200_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp6_M_2600_TuneZ2star_13TeV_pythia6_cff.py |
| HSCPmchamp6_M_300_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp6_M_400_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp6_M_600_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp6_M_800_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp6_M_900_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp9_M_300_TuneZ2star_13TeV_pythia6_cff.py  |
| HSCPmchamp9_M_900_TuneZ2star_13TeV_pythia6_cff.py  |
|----------------------------------------------------|

***** Creating by Hand

      AOD files include all of the information from the simulation. That
      is, everything from the detector is included. We do not need all
      of this information, and it will get stripped down later. An
      example command to create configuration files for the creation of
      the AOD files is as follows:

    #+BEGIN_EXAMPLE
      cmsDriver.py Configuration/GenProduction/python/ThirteenTeV/HSCPmchamp6_M_1400_TuneZ2star_13TeV_pythia6_cff.py --fileout file:mchamp6_M_1400_AOD.root --mc --eventcontent AODSIM --datatier GEN-SIM-DIGI-AOD --conditions MCRUN2_74_V8 --step GEN,SIM,DIGI,L1,DIGI2RAW,HLT:GRun,RAW2DIGI,L1Reco,RECO --python_filename mchamp6_M_1400__cfg.py --magField 38T_PostLS1 --geometry Extended2015 --customise SimG4Core/CustomPhysics/Exotica_HSCP_SIM_cfi.customise,SLHCUpgradeSimulations/Configuration/postLS1Customs.customisePostLS1 --no_exec -n 10
    #+END_EXAMPLE
***** Creating by Automation

    Automation of the above has been accomplished by means of a
    bash script. This script will create the corresponding
    configuration file for the given charge, mass and event number as
    specified in the appropriate org code snippet variables available
    below in the runner.
    #+NAME: cfg-creator
    #+BEGIN_SRC sh :exports code :tangle ../HSCP_MC_Creation/Scripts/cfgCreator.sh 
      #!/bin/bash
      CHARGE=$1
      MASS=$2
      EVENTS=$3
      cmsDriver.py Configuration/GenProduction/python/ThirteenTeV/HSCPmchamp${CHARGE}_M_${MASS}_TuneZ2star_13TeV_pythia6_cff.py --fileout file:mchamp${CHARGE}_M_${MASS}_AOD.root --mc --eventcontent AODSIM --datatier GEN-SIM-DIGI-AOD --conditions MCRUN2_74_V8 --step GEN,SIM,DIGI,L1,DIGI2RAW,HLT:GRun,RAW2DIGI,L1Reco,RECO --python_filename mchamp${CHARGE}_M_${MASS}_cfg.py --magField 38T_PostLS1 --geometry Extended2015 --customise SimG4Core/CustomPhysics/Exotica_HSCP_SIM_cfi.customise,SLHCUpgradeSimulations/Configuration/postLS1Customs.customisePostLS1 --no_exec -n ${EVENTS}
    #+END_SRC

    The above can be run in the appropriate directory by executing the
    following within the Org file:
    #+NAME: cfg-creator-runner
    #+BEGIN_SRC sh :exports both :results output :var mass="1400" :var charge="6" :var events="1000" :dir /ssh:askeeter@lxplus.cern.ch:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/
      sh cfgCreator.sh ${charge} ${mass} ${events} 
    #+END_SRC
**** Running Configuration Files

     Once all of these steps, whether by hand or by automation have
     been completed, the user should be left with all of the
     requested AOD Root files, as well as the left over configuration
     files for everything that has been ran.
***** Running by Hand     

      Now, once the appropriate configuration files are created, they
      need to be sent to the CERN Batch service to run. The above
      cmsDriver command includes all steps including the full
      simulation. To send files to the batch service, a script must be
      used. An example script is as follows:
      
    #+NAME: batch-script-example
    #+BEGIN_SRC sh
      #! /bin/sh
      CMSSW_PROJECT_SRC="/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/"
      CFG_FILE="mchamp6_M_1400_cfg.py"
      OUTPUT_FILE="mchamp6_M_1400.root"
      TOP="$PWD"

      cd $CMSSW_PROJECT_SRC
      eval `scramv1 runtime -sh`
      cd $TOP
      cmsRun $CMSSW_PROJECT_SRC/$CFG_FILE
      rfcp $OUTPUT_FILE $CMSSW_PROJECT_SRC$OUTPUT_FILE
    #+END_SRC

      After the script is created though, make sure to change the file
      permissions with:
    #+BEGIN_SRC sh
      chmod 744 lxplusbatchscript.sh
    #+END_SRC
    
      Now the job(s) must be submitted to the batch service:
    #+NAME: batch-sender-example
    #+BEGIN_SRC sh
      bsub -R "pool>30000" -q 1nw -J job1 < lxplusbatchscript.csh
    #+END_SRC
      Where the following options are true: 
    - "-R" "pool>30000" means that you want a minimum free space of 30GB
    to run your job. 
    - "-q" 1nw means you are submitting to the 1-week que. Other available
    queues are:
     - 8nm (8 minutes)
     - 1nh (1 hour)
     - 8nh
     - 1nd (1 day)
     - 2nd (2 days)
     - 1nw (1 week)
     - 2nw
     - -J job1 sets job1 as your job name
     - < lxplusbatchscript.sh gives your script to the job.
       
     Check your job status with: "bjobs"
     Kill jobs with "bkill -J job1"
     Using bkill without any job specified will kill ALL of your jobs.

***** Running by Automation

      All of the aforemntioned can be accomplished automatically by
      means of the following scripts:

      #+NAME: batch-creator  
      #+BEGIN_SRC sh :exports both :tangle ../HSCP_MC_Creation/Scripts/batchCreator.sh :dir /ssh:askeeter@lxplus.cern.ch:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src
        #!/bin/bash

        #Populate an array of all of the configuration files
        shopt -s nullglob
        filearray=( "HSCP_MC_cfg_Files"/* )
        shopt -u nullglob

        #Create a bash file for each config file
        for file in "${filearray[@]}"
        do
            parts=(${file//_/ })
            charge=${parts[3]}
            #Extract the number from the charge
            chargeFixed=$(echo $charge | tr -dc '0-9')
            mass=${parts[5]}

            #All of the important data has been stripped from the config filename
            #Now to create the bath scripts
            filename="mchamp${chargeFixed}_M_${mass}.sh"
            cfgfile="mchamp${chargeFixed}_M_${mass}_cfg.py"
            rootfile="mchamp${chargeFixed}_M_${mass}_AOD.root"
            #Create an empty file to be filled
            touch $filename
            #Use echo to populate the file contents. Not the cleanest way, but it works for a file this short.
            echo "#!/bin/sh">$filename
            echo 'CMSSW_PROJECT_SRC="/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/"'>>$filename
            echo """CFG_FILE='/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_cfg_Files/${cfgfile}'""">>$filename
            echo """OUTPUT_FILE='/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_Root_Files/$rootfile'""">>$filename
            echo "OUT_FILE='$rootfile'">>$filename
            echo 'TOP="$PWD"'>>$filename
            echo 'cd $CMSSW_PROJECT_SRC'>>$filename
            echo 'eval `scramv1 runtime -sh`'>>$filename
            echo 'cd $TOP'>>$filename
            echo 'cmsRun $CFG_FILE'>>$filename
            echo 'rfcp $OUT_FILE $OUTPUT_FILE'>>$filename
            #DO NOT FORGET to change the config file permissions if you are creating these by hand.
            chmod 744 $filename
        done

      #+END_SRC

      The above places all created files in certain directories that
      are expected to remain constant. Should these change, all of the
      automation scripts will need to be updated, although the "by
      hand" methods will remain independent.
      
      After running the batch-creator script, we will have all of the
      necessary batch files that we need to run in order to utilize
      the appropriate configuration file to produce a corresponding
      AOD Root file.
      
      #+NAME: batch-sender
      #+BEGIN_SRC sh :exports both :tangle ../HSCP_MC_Creation/Scripts/batchSender.sh :dir /ssh:askeeter@lxplus.cern.ch:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src
        #!/bin/bash

        #Populate an array of all of the batch scripts 
        shopt -s nullglob
        filearray=( "HSCP_MC_sh_Files"/* )
        shopt -u nullglob

        for file in "${filearray[@]}"
        do
            #Strip off the chracters that we dont need
            fileFixed=${file:17}
            #Send to the two day queue. This can be changed
            bsub -R "pool>20000" -q 2nd -J $fileFixed < /afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_sh_Files/$fileFixed
        done

      #+END_SRC
      
*** EDM Files
**** Creation by Hand

    Once the creation of the AOD files is complete, they need to be
    converted into something that is a bit smaller, containing only
    the information that we need. Basically, this process involves
    cutting out some of the "meat" of the AOD files, reducing their
    size, but not (at least for our purposes) their utility.
    
    A single file needs to be modified that dictates to cmsRun which
    AOD file that you would like to convert to EDM. The file resembles
    the following:

    #+BEGIN_SRC python
      import sys, os
      import FWCore.ParameterSet.Config as cms
      #Makes EDM from AOD
      isSignal = True
      isBckg = False
      isData = False
      isSkimmedSample = False
      GTAG = 'MCRUN2_74_V8'
      OUTPUTFILE = '/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_Root_Files/mchamp3_M_400_EDM.root'

      #InputFileList = cms.untracked.vstring()

      #debug input files 
      #this list is overwritten by CRAB
      InputFileList = cms.untracked.vstring(
          #The comment is an example of how to do this from a remote directory
          #'root://cmseos.fnal.gov//eos/uscms/store/user/aackert/HSCP/AODgen/condorjdls/step2_condortest.root',
          #Below is the file that you want to conver from AOD to EDM
          'file:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_Root_Files/mchamp3_M_400_AOD.root'
      )


      #main EDM tuple cfg that depends on the above parameters
      execfile( os.path.expandvars('${CMSSW_BASE}/src/SUSYBSMAnalysis/HSCP/test/MakeEDMtuples/HSCParticleProducer_cfg.py') )
    #+END_SRC

    This file is located at:
    =/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/SUSYBSMAnalysis/HSCP/test/MakeEDMtuples/HSCParticleProducer_Signal_cfg.py=

    The lines that need to be altered here are "OUTPUTFILE", and
    'file:/afs/cern/ch/...' which are basically telling the program
    the name of the EDM file that you would like created when the
    cmsRun has been ran, and the name of the input file(s). If you
    have had to split up a job into multiple smaller files (that is,
    you have split up a large AOD into several smaller ones), simply
    include the names of each of those files in the "InputFileList",
    separated by commas and endlines. It is simply a python array.

    Once this file has been altered, the conversion is accomplished
    simply by running the following:

    #+BEGIN_SRC sh
      cmsRun HSCParticleProducer_Signal_cfg.py
    #+END_SRC
    
    These jobs can also be sent to the batch service if you would
    like, however scripts would still need to be created just as with
    the AOD files.

**** Creation by Automation

     All of the aforementioned can be accomplished by means of two
     automation scripts. One script, as with the batchCreator script,
     is only responsible for the creation of the Python configuration
     file dictating the terms of the AOD to EDM conversion. The other,
     as is similar again, is responsible for executing the conversion
     jobs.

     #+NAME: aod-to-edm-creator
     #+BEGIN_SRC sh :exports both :tangle ../HSCP_MC_Creation/Scripts/AodToEdmCreator.sh :dir /ssh:askeeter@lxplus.cern.ch:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src
       #!/bin/bash

       #Populate an array of all of the AOD files
       shopt -s nullglob
       filearray=( "HSCP_MC_Root_Files"/*AOD* )
       shopt -u nullglob

       for file in "${filearray[@]}"
       do
           parts=(${file//_/ })
           charge=${parts[3]}
           #Extract the number from the charge
           chargeFixed=$(echo $charge | tr -dc '0-9')
           mass=${parts[5]}    
           aod_file="mchamp${chargeFixed}_M_${mass}_AOD.root"
           root_file="mchamp${chargeFixed}_M_${mass}_EDM.root"
           python_file="mchamp${chargeFixed}_M_${mass}_cfg.py"
           
           cat > /afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_AODtoEDM_Python_Files/${python_file} << EOF
       import sys, os
       import FWCore.ParameterSet.Config as cms
       #Makes EDM from AOD
       isSignal = True
       isBckg = False
       isData = False
       isSkimmedSample = False
       GTAG = 'MCRUN2_74_V8'
       OUTPUTFILE = '/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_Root_Files/${root_file}'

       InputFileList = cms.untracked.vstring(
       'file:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_Root_Files/${aod_file}'
       )

       execfile( '${CMSSW_BASE}/src/SUSYBSMAnalysis/HSCP/test/MakeEDMtuples/HSCParticleProducer_cfg.py' )
       EOF
           
       done

     #+END_SRC
     
     #+NAME: aod-to-edm-runner
     #+BEGIN_SRC sh :exports both :tangle ../HSCP_MC_Creation/Scripts/AodToEdmRunner.sh :dir /ssh:askeeter@lxplus.cern.ch:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src
       #!/bin/bash

       shopt -s nullglob
       filearray=( "HSCP_MC_Root_Files"/*AOD* )
       shopt -u nullglob

       for file in "${filearray[@]}"
       do
           parts=(${file//_/ })
           charge=${parts[3]}
           #Extract the number from the charge
           chargeFixed=$(echo $charge | tr -dc '0-9')
           mass=${parts[5]}    
           aod_file="mchamp${chargeFixed}_M_${mass}_AOD.root"
           root_file="mchamp${chargeFixed}_M_${mass}_EDM.root"
           python_file="mchamp${chargeFixed}_M_${mass}_cfg.py"
          
           #Replace the standard configuration file with the one currently being ran
           cp /afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/HSCP_MC_AODtoEDM_Python_Files/${python_file} /afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/SUSYBSMAnalysis/HSCP/test/MakeEDMtuples/HSCParticleProducer_Signal_cfg.py
           cd /afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/SUSYBSMAnalysis/HSCP/test/MakeEDMtuples/
           cmsRun HSCParticleProducer_Signal_cfg.py
           #Don't do the next file until the previous one has ran to completion, as these jobs are not sent to batch
           wait
       done
     #+END_SRC
*** Usable NTuples
**** Creating by Hand

    Once we have EDM files, we are ready to create usable ROOT files
    that we can perform analysis on. In order to do so, we have to
    call on the Launch.py program located in:

    =/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/SUSYBSMAnalysis/HSCP/test/AnalysisCode/Launch.py=
    
    Before calling this though, we must tell Launch which files that
    we would like to act on. This is accomplished by editing the
    "Analysis_Samples.txt" file which is located in the same directory
    as Launch. An example of this file is as follows:

    #+BEGIN_EXAMPLE
    #RELEASE, SAMPLE TYPE (0=data, 1=bckg, 2=signal, 3=signal systematic), SIGNAL NAME, INPUT FILE NAME, Legend Entry, PILEUP Distribution, Signal Mass, Sample Cross-section, PLOTTING FLAG (0=false, 1=true), Weight for events with 0, 1 and 2 charged HSCP in the event
    #HSCP Signal
    #"CMSSW_7_4",  2, "MChamp9_13TeV_M900"                , "MChamp9_13TeV_M900"            , "MC: mchamp9 900 GeV/#font[12]{c}^{2}"                     , "S10"   ,    900, +2.5000000000E-03, 1, 1.000, 1.000, 1.000
    #
    #"CMSSW_7_4",  2, "MChamp6_13TeV_M900"                , "MChamp6_13TeV_M900"            , "MC: mchamp6 900 GeV/#font[12]{c}^{2}"                     , "S10"   ,    900, +2.5000000000E-03, 1, 1.000, 1.000, 1.000
    "CMSSW_7_4",   2, "mchamp18_M_300"                    , "mchamp18_M_300_EDM"            , "MC: mchamp6 900 Gev/#font[12]{c}^{2}"                     , "S10"   ,    300, +2.5000000000E-03, 1, 1.000, 1.000, 1.000


    #
    #
    #
    #Background
    #"CMSSW_7_4", 1, "MC_13TeV_DYToMuMu"                  , "MC_13TeV_DYToMuMu"                     , "MC: DYToMuMu"                            , "S10"   ,      0, +1.3389000000E+03, 0, 0.000, 0.000, 0.000
    #+END_EXAMPLE

    There are several potential things that could be edited in this
    file, but we mainl only need to edit three. The first column
    corresponds to the version of CMSSW being used. The second
    corresponds to the sample type being read in, where keys and
    meanings are displayed at the top of the file. The third column is
    the desired name of the output data file once conversion is
    complete. The fourth column corresponds to the name of the input
    EDM file, with no ".root" extension. The next column is a label
    to be used in plots produced by steps two and higher. The next
    column "s10" does not need to be changed.This is the type of
    pileup distribution. The next column must be changed to equal the
    mass of the desired particle in GeV/c^2. None of the other numbers
    need to be changed. It is of course possible to process multiple
    files in this step. 

    In order to produce usable tuples, we must simply run step
    one. Step one converts our EDM files to a usable root file. 
    Now that the above file has been properly edited, we simply run:

    #+BEGIN_SRC sh
      Launch.py 1
    #+END_SRC

    Which will run step 1 of the analysis code. Upon completion, the
    data root tuples will be stored in the "Results" folder of the
    same directory as Launch. It should be noted that the jobs are
    auto-batched to Cern's 2 day queue. 

    Once can also run the jobs locally by looking in the "FARM/inputs"
    folder. You will see ####_HscpAnalysis.sh where the numbers
    correspond to the batched job number. Less them and the bottom
    lines will tell you what samples they are running on if you're not
    sure. Then just do:

    #+BEGIN_SRC sh
      source filename.sh >& output.txt &
    #+END_SRC

    To run locally (and redirect the output). Running locally is
    usually faster than sending to batch, but if the local running
    takes longer than two hours, the job will be killed automatically.
   
**** Creating by Automation

     The following script will simply populate the
     "AnalysisSamples_Gloabal.txt" file with all of the EDM files that
     are available for conversion. Careful with this program though,
     as it merely appends to the already existing file. It is best to
     delete the contents of the already existing file before running
     this in order to avoid the creation of duplicate files. 
     
     #+NAME: edm-to-ntuple-creator
     #+BEGIN_SRC sh :exports both :tangle ../HSCP_MC_Creation/Scripts/EdmToNtupleCreator.sh :dir /ssh:askeeter@lxplus.cern.ch:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src
       #!/bin/bash

       shopt -s nullglob
       filearray=( "HSCP_MC_Root_Files"/*EDM* )
       shopt -u nullglob
       #printf "%s\n" "${filearray[@]}"
       appendTo="/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/SUSYBSMAnalysis/HSCP/test/AnalysisCode/Analysis_Samples.txt"
       #Create a python file for each config file    
       for file in "${filearray[@]}"
       do
           parts=(${file//_/ })
           charge=${parts[3]}
           #Extract the number from the charge
           chargeFixed=$(echo $charge | tr -dc '0-9')
           mass=${parts[5]}    
           aod_file="mchamp${chargeFixed}_M_${mass}_AOD.root"
           edm_file="mchamp${chargeFixed}_M_${mass}_EDM"
           gen_file="mchamp${chargeFixed}_M_${mass}"
           #We need to append to the Analysis_Samples.txt file
           cat >> /afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/SUSYBSMAnalysis/HSCP/test/AnalysisCode/Analysis_Samples.txt << EOF
       "CMSSW_7_4",   2, "$gen_file"    ,"$edm_file"    , "MC: mchamp${chargeFixed} ${mass} GeV/#font[12]{c}^{2}" , "S10", $mass, +9.8480000000E+01, 0, 1.000, 1.000, 1.000
       EOF
       done
            
     #+END_SRC

     Once the list has been populated, the next step is the same as
     the above. Simply run:

     #+NAME: launch-Step-1
     #+BEGIN_SRC sh :exports code :dir /ssh:askeeter@lxplus.cern.ch:/afs/cern.ch/work/a/askeeter/private/CMSSW_7_4_4_patch4/src/SUSYBSMAnalysis/HSCP/test/AnalysisCode/
Launch.py 1
     #+END_SRC
     
*** Plots

    Step 2 of the analysis code involves generating plots. In order to
    run this step, you must simply use the number "2" with Launch.py,
    similar to the previous step. However, you must make sure to edit
    the file "Analysis_Global.h" located in the Launch.py directory,
    around line 157. Make sure that the "BaseDirectory" points to
    where your samples being analyzed are located. Then, you can
    simply run step 2 AFTER step 1.
    
** MC Analysis
Once Monte Carlo samples have been created, they can be analyzed in
order to get a feel for what HSCPs will look like with regards to
relevant physics variables. 

The two snippets below allow the macro to be saved to two locations:
one local, and one on the CMS computers, where it will be compiled.


blah#+HEADERS: :tangle ~/HSCP_Study/HSCP_MC_Analysis/Macros/MC_Analyzer.cpp :noweb tangle
#+BEGIN_SRC cpp
<<MC_Analyzer.cpp>>
#+END_SRC

#+HEADERS: :tangle /sftp:austin.skeeters@cms03.hep.fsu.edu:/storage/6/work/askeeters/HSCPStudy/HSCP_Analyzers/MC_Analyzer.cpp :noweb tangle
#+BEGIN_SRC cpp
<<MC_Analyzer.cpp>>
#+END_SRC

#+NAME: MC_Analyzer.cpp
#+BEGIN_SRC cpp 
#include <cstddef> //size_t
#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <sstream>
#include <string>
#include <cmath>
#include <map>
#include <unordered_map>
#include <vector>
#include <array>
#include <iterator>
#include "format.h"
#include <TROOT.h> //for gROOT
#include <TFile.h>
#include <TTree.h>
#include <TBranch.h>
#include <TH1.h>
#include <TGraph.h>
#include <TCanvas.h>
#include <TMathBase.h>
#include <TMath.h>
#include <TNetFile.h>
#include <TAuthenticate.h>
#include <TObject.h>
#include <TApplication.h>
#include <TNamed.h>

using namespace std;
  
class Key{
public:
  Key(string dist,string type,int charge,int mass){
    this->dist = dist;
    this->charge = charge;
    this->mass = mass;
    this->type = type;
    this->name = fmt::format("{}_{}_{}_{}",type,dist,charge,mass);
  }

  string dist;
  string type;
  int charge;
  int mass;
  string name;
  
  bool operator<(const Key &k) const{
    return (this->name<k.name);
  }
  
  bool operator==(const Key &rhs){
    return this->dist == rhs.dist && this->charge == rhs.charge && this->mass == rhs.mass && this->type == rhs.type;
  }
  
};

struct distObjects{
  TCanvas *canvas;
  TH1F *distribution;
  distObjects() : canvas(NULL), distribution(NULL) {}
  distObjects(const distObjects &arg) : canvas(arg.canvas), distribution(arg.distribution) {}
  distObjects(TCanvas *&aCanv, TH1F *&aDist) : canvas((TCanvas*)aCanv->Clone()), distribution((TH1F*)aDist->Clone()) {}
};

typedef map<Key,distObjects> distMap;
typedef pair<string,string> axes;
typedef pair<double,double> limits;

struct distProp{
  limits axisLimits;
  double nBins;
  axes axisTitles;
};

//typedef map< Key, pair<TCanvas, TH1F> > distMap;

// TCanvas *canv_Preco_Vs_Pgen[nCHARGE][nMASS];
// TCanvas *canv_Tofreco_Vs_Tofgen[nCHARGE][nMASS];
// TCanvas *canv_Ihreco_Vs_Ihgen[nCHARGE][nMASS];

/*
  Function to insert available ROOT MC Sample files into a string array.
  Make the first entry in the array a string containing the number of 
  entries in the array, INCLUDING this entry.
*/

static string *ListOfFiles(){
  FILE *inStream;
  char charnFiles[10];
  char charFiles[10000];
  stringstream streamnFiles;
  
  //First, count how many files we will be reading
  if(!(inStream = popen("ls /home/austin/HSCP_Study/HSCP_MC_Files/*.root -l | wc -l", "r"))){
    exit(0);
  }
    
  while(fgets(charnFiles, sizeof(charnFiles), inStream)!=NULL){
    streamnFiles << charnFiles;
  }
  pclose(inStream);

  int nFiles = atoi(streamnFiles.str().c_str());
  //cout << "nFiles form function: " << nFiles << endl;
  string *listOfFiles = new string[nFiles+1];

  //Now we have the number of files, and can dynamicall allocate a string array for it.
  //PLUS the first entry containing the number of entries in the arary.
  
  listOfFiles[0] = streamnFiles.str();
  
  //Now we need to read in the list of files
  //Will do something similar to the above, but using this method to get only the file names
  stringstream testStream;
  if(!(inStream = popen("find /home/austin/HSCP_Study/HSCP_MC_Files/*.root -printf \"%f\n\"","r"))){
    exit(0);
  }
  while(fgets(charFiles, sizeof(charFiles), inStream)!=NULL){
    testStream << string(charFiles);
  }
  pclose(inStream);
  
  string line;
  int fNum = 1;
  while(getline(testStream,line)){
    listOfFiles[fNum] = line;
    fNum++;
  }
  
  return listOfFiles;
}

/*Function to parse a file name into mass and charge */
//Create a struct to allow returning both mass and charge
//as parsed from the file name
struct NameDat{
  double *charge;
  double *mass;
  string *fileNames;
  map<double,int> chargeCounts;
  map<double,int> massCounts;
};

//Actual function that will parse the file name and return a NameDat struct
static NameDat *FileNameParser( string *Names, const int nFiles ){
  NameDat *outDat = new NameDat; //Struct that will contain the parsed mass and charge
  outDat->charge = new double[nFiles];
  outDat->mass = new double[nFiles];
  outDat->fileNames = Names+1;
  
  //the one comes from the fact that the file
  //name array has the number of files as the
  //first character
  for(int iFile = 0; iFile < nFiles; iFile++){
    string aName = outDat->fileNames[iFile];
    string chunks[4]; //string array that will contain the chunks
    //Loop through each character of the file name, increasing iCh.
    //Increase iChunk at each chunk ('_' character)
    //Store each chunk in a string array (chunks)
    //Clean up the chunks of interest, and return the data in the struct
    size_t found = aName.find_first_of("_");
    
    chunks[0] = aName.substr(0,found);
    int chunkPos = 1;
    while( found != string::npos ){
      chunks[chunkPos] = aName.substr(found+1,aName.find_first_of('_',found+1)-found-1);
      found = aName.find_first_of('_',found+1);
      chunkPos++;
    }
    //Charge is in chunk 1, mass in chunk index 3
    //Clean the mass and charge chunks.
    string charge = chunks[1].substr(chunks[1].find_first_not_of("mchamp"),string::npos);
    string mass = chunks[3].substr(0,chunks[3].find_first_of(".root"));

    //Convert the strings to floats/doubles
    outDat->charge[iFile] = atof(charge.c_str())/3.0;
    outDat->mass[iFile] = atof(mass.c_str());
  }
  
  map<double, int> massCounts;
  map<double, int> chargeCounts;
  
  //Count the masses
  for( int iMass = 0; iMass < nFiles; iMass++ ){
    if( !massCounts.insert( make_pair(outDat->mass[iMass], 1 ) ).second ){
      //Element is alread present. Need to increment the count
      massCounts[outDat->mass[iMass]] += 1;
    }
  }

  //Count the charges
  for( int iCharge = 0; iCharge < nFiles; iCharge++ ){
    if( !chargeCounts.insert( make_pair(outDat->charge[iCharge], 1 ) ).second ){
      //Element is alread present. Need to increment the count
      chargeCounts[outDat->charge[iCharge]] += 1;
    }
  }

  outDat->chargeCounts = chargeCounts;
  outDat->massCounts = massCounts;
  return outDat;
}


//For each distribution type, go through all files (masses and charges)
static void AllocateDistributions( distMap &argDists, const double *charges, const double *masses, const int &numFiles, const vector<string> &distNames, map<string,distProp> &distProps){
  const string type = "Reco";
  for (auto iNames = distNames.begin(); iNames != distNames.end(); ++iNames) {
    double *lowerLim = &distProps[*iNames].axisLimits.first;
    double *upperLim = &distProps[*iNames].axisLimits.second;
    double *nBins = &distProps[*iNames].nBins;
    string xAxis(distProps[*iNames].axisTitles.first);
    string yAxis(distProps[*iNames].axisTitles.second);
    
    for (int iFile=0; iFile < numFiles; iFile++) {
      Key entryKey (*iNames,type,(int)(3* charges[iFile]),(int)masses[iFile]);
      
      string canv_name = entryKey.name + "_canv";
      string dist_name = entryKey.name + "_dist";

      yAxis = fmt::format(yAxis.c_str(), (*upperLim-*lowerLim) / *nBins);
      TCanvas *tempCanv = new TCanvas(canv_name.c_str(),canv_name.c_str(),500,500);
      TH1F *tempHist = new TH1F(dist_name.c_str(),dist_name.c_str(),*nBins,*lowerLim,*upperLim);

      tempHist->GetXaxis()->SetTitle(xAxis.c_str());
      tempHist->GetYaxis()->SetTitle(yAxis.c_str());
      argDists.emplace(entryKey,distObjects(tempCanv,tempHist));
    }
  }
}

static void AllocateOutfile( TFile *&aFile, const vector<string> &distNames ){
  aFile->mkdir("Reco");
  aFile->mkdir("Gen");
  for (const auto &iNames : distNames) {
    aFile->cd("Reco");
    gDirectory->mkdir(iNames.c_str());
    aFile->cd("Gen");
    gDirectory->mkdir(iNames.c_str());
  }
  aFile->cd("/");
}

/*Main*/
int main(int argc, char **argv){
  //TApplication theApp("App",&argc,argv);

  gROOT->SetStyle("Plain");
  gROOT->ForceStyle();
  gROOT->SetBatch(kTRUE); //Don't draw things when created.
  
  string *fileList = ListOfFiles(); 

  //Total number of files to be processed
  int numFiles = atoi(fileList[0].c_str());

  NameDat *fileNameData = FileNameParser( fileList, numFiles );
  
  //Arrays of the charges and masses associated with each file
  double *masses = fileNameData->mass;
  double *charges = fileNameData->charge; //These are the ACTUAL charges

  //List of the names of the files to be opened
  fileList = fileNameData->fileNames; //Can index from 0 now
  
  // //Number of each charge and each mass
  map<double,int> chargeCounts = fileNameData->chargeCounts;
  map<double,int> massCounts = fileNameData->chargeCounts;

  distMap distList;
  vector<string> distNames = {
    "beta",
    "energy",
    "eta",
    "gamma",
    "Ih",
    "momentum",
    "phi",
    "trans_momentum",
    "theta",
    "TOF",
    "TOFdivTRel"
  };
  map<string,distProp> distProps = {
    {"beta",{limits(0.9,1.0),200,axes("#beta","events/{}")}},
    {"energy",{limits(0.9,1.0),200,axes("E [GeV]","events/{} GeV")}},
    {"eta",{limits(0.9,1.0),200,axes("#eta", "events/{}")}},
    {"gamma",{limits(0.9,1.0),200,axes("#gamma", "events/{}")}},
    {"Ih",{limits(0.9,1.0),200,axes("I_{h} [MeV/cm]", "events/{} MeV/cm")}},
    {"momentum",{limits(0.9,1.0),200,axes("P [GeV/c]", "events/{} GeV/c")}},
    {"phi",{limits(0.9,1.0),200,axes("#phi [deg]", "events/{} deg")}},
    {"trans_momentum",{limits(0.9,1.0),200,axes("P_{t} [GeV/c]", "events/{} GeV/c")}},
    {"theta",{limits(0.9,1.0),200,axes("#theta [deg]", "events/{} deg")}},
    {"TOF",{limits(0.9,1.0),200,axes("t [s]", "events/{} s")}},
    {"TOFdivTRel",{limits(0.9,1.0),200,axes("#frac{t}{t_{r}}", "events/{}")}}
  };

  
  AllocateDistributions(distList,charges,masses,numFiles,distNames,distProps);
  
  
  //Pointer for the tree being read
  TTree *tree;
  unsigned int event;
  unsigned int Hscp;
  float E;
  float Pt, P;
  float I;
  float Ih; //This is the energy deposition that we are interested in 
  float TOF; 
  float Mass; //Reco mass. Not correct. Assumes unit charge
  float dZ, dXY, dR;
  float eta, phi, theta;
  float beta, gamma;
  bool hasMuon;

  //Loop over the files
  for( int iFile = 0; iFile < numFiles; iFile++ ){
    string file = "/home/austin/HSCP_Study/HSCP_MC_Files/";
    file += fileList[iFile];
    TFile *datFile = new TFile(file.c_str(), "READ"); //Open the current file

    double *charge = &charges[iFile];
    double *mass = &masses[iFile];
    string type = "Reco";
    //Create a string for the appropriate file directory
    ///storage/6/work/askeeters/HSCPStudy/HSCP_Root_Files
    string mcDir(fmt::format("mchamp{}_M_{}/HscpCandidates",3*charges[iFile],masses[iFile]));

    //Set the appropriate branches for the MC particles
    tree = (TTree*)datFile->Get(mcDir.c_str());
    
    tree->SetBranchAddress("Event", &event);
    tree->SetBranchAddress("Hscp", &Hscp);
    tree->SetBranchAddress("Pt",&Pt);
    tree->SetBranchAddress("I",&I);
    tree->SetBranchAddress("Ih",&Ih);
    tree->SetBranchAddress("TOF",&TOF);
    tree->SetBranchAddress("Mass",&Mass);
    tree->SetBranchAddress("dZ",&dZ);
    tree->SetBranchAddress("dXY",&dXY);
    tree->SetBranchAddress("dR",&dR);
    tree->SetBranchAddress("eta",&eta);
    tree->SetBranchAddress("phi",&phi);
    tree->SetBranchAddress("hasMuon",&hasMuon);
    
    //Loop over the events
    //cout << fmt::format("{:<12}{:<12}{:<12}{:<12}{:<12}{:<12}{:<12}{:<12}", "event", "Pt(GeV)", "Ih(MeV/cm)", "Mass(GeV)", "eta", "phi", "theta(deg)","E") << endl;
    for(int iEvt = 0; iEvt < tree->GetEntries(); iEvt++){
      tree->GetEntry(iEvt);
      
      //Calculate theta
      theta = 2*TMath::ATan( TMath::Exp( -1 * eta ) );
      //Calculate Momentum from transverse and theta (rad)
      P = Pt / TMath::Sin(theta);
      
      //Calculate the relativistic energy
      E = TMath::Sqrt( P*P + masses[iFile] );

      //Calculate beta
      beta = P / E;
      //Fill beta distribution
      
      Key betaKey (string("beta"), type, (int)(3* *charge), (int)*mass);
      distList[betaKey].distribution->Fill(beta);
      

      //Calculate gamma
      gamma = 1.0 / TMath::Sqrt( 1 - beta*beta );
      
      //Fill the gamma distribution
      //fillIt = distList.find( "gamma" );
      // fillIt->second.second.second->Fill(gamma);

      
    }//end event loop
    datFile->Close();
  }//end file loop
  
  //Loop through all available distributions, writing them to the disc.
  TCanvas *currCanv;
  TH1F *currDist;
  double norm = 1;

  //Data output file
  TFile *outFile = new TFile("HSCP_MC_Analysis.root","RECREATE");
  //Set up the outfile to have a folder for each data type
  AllocateOutfile(outFile, distNames);
  
  //Loop through each distribution (eta,beta,gamma,etc)
  outFile->cd("Reco");
  for(const auto &distIt : distList){
    string dir = string("Reco/") + distIt.first.dist;
    outFile->cd(dir.c_str());
    currDist = distIt.second.distribution;
    currDist->Scale(norm/currDist->Integral("width"));
    currDist->Write();
    outFile->cd("/");
  }

  // for(const auto &distIt : GammaDist){
  //   currDist = distIt.second.second;
  //   currDist->Scale(norm/currDist->Integral("width"));
  //   currDist->Write();
  // }
  
  cout << "Finished writing to file" << endl;
  outFile->Close();
  //theApp.Run();
  return 0;
}

#+END_SRC

To compile and run the above program on cms07 at FSU, execute the
following, and note that compilation occurs on the local pc:
#+NAME: MC_Analyzer_Local_Compiler.sh
#+HEADERS: :results output replace
#+BEGIN_SRC sh
cd /home/austin/HSCP_Study/HSCP_MC_Analysis/Macros/
rm *.exe
g++ -std=c++11 `root-config --cflags` MC_Analyzer.cpp format.cc `root-config --glibs` -lEG -o MC_Analysis.exe -fpermissive
#./MC_Analysis.exe 2>&1
#+END_SRC

#+RESULTS: MC_Analyzer_Local_Compiler.sh



#+NAME: MC_Analyzer_Compiler.sh
#+HEADERS: :dir /ssh:austin.skeeters@cms07.hep.fsu.edu:/storage/6/work/askeeters/HSCPStudy/HSCP_Analyzers/ 
#+HEADERS: :results output replace
#+BEGIN_SRC sh
source ~/SETUPALL.sh &> setup.out
cd /storage/6/work/askeeters/HSCPStudy/HSCP_Analyzers/
#./MC_Analysis.exe
#+END_SRC

#+RESULTS: MC_Analyzer_Compiler.sh








* Playing around with org examples                                   :export:

  #+begin_src python :results file
    import matplotlib, numpy
    #matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    fig=plt.figure(figsize=(4,2))
    x=numpy.linspace(-15,15)
    plt.plot(numpy.sin(x)/x)
    fig.tight_layout()
    plt.savefig('/tmp/python-matplot-fig.png')
    return '/tmp/python-matplot-fig.png' # return filename to org-mode
#+end_src

  #+RESULTS:
  [[file:/tmp/python-matplot-fig.png]]

  #+BEGIN_SRC cpp
    #include <iostream>
    using namespace std;
    int main(void){
      cout << "Hello world!" << endl;
      }
  #+END_SRC

  #+RESULTS:
  : Hello world!
 
  $-\left<\frac{dE}{dx}\right>=4\pi
        N_{A}r_{e}^2m_{e}c^2z^2\frac{Z}{A}\frac{1}{\beta^2}\left[\frac{1}{2}\ln\frac{2m_ec^2\beta^2\gamma^2T_{max}}{I^2}-\beta^2-\frac{\delta(\beta\gamma)}{2}\right]\times
        Q^2$



  
* Code Snippets                                                      :export:
** Bash script populate array of all files

   To populate an array of all of the files in a certain folder you
   can do something similar to:
   #+BEGIN_SRC sh
     shopt -s nullglob
     filearray=( "HSCP_MC_sh_Files"/* )
     shopt -u nullglob
     #Now to loop through them
     for file in "${filearray[@]}"
     do
         #strip off the characters that we don't need
         fileFixed=${file:17}
     done
   #+END_SRC
   This is what I use in my script that sends jobs to the cern batch
   service, as well as my script that creates the batch shell files
   based on the available configuration files.
** Bash script extract numbers from filename

   Similar to the above, we must first obtain a file name that we wish
   to parse. So:
   #+BEGIN_SRC sh
     shopt -s nullglob
     filearray=( "HSCP_MC_cfg_Files"/* )
     shopt -u nullglob
     #Now to loop through them
     for file in "${filearray[@]}"
     do
         parts=(${file//_/ })
         charge=${parts[3]}
         #extract the number from the charge
         chargeFixed=$(echo $charge | tr -dc '0-9')
         mass=${parts[5]}
         #Now we have our relevant info from the file!
     done
   #+END_SRC 
